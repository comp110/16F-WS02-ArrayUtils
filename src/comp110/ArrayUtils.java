package comp110;

/**
 * Author:
 *
 * ONYEN:
 *
 * Collaborator(s):
 *
 * UNC Honor Pledge: I certify that no unauthorized assistance has been received
 * or given in the completion of this work. I certify that I understand and
 * could now rewrite on my own, without assistance from collaborators or course
 * staff, the problem set code I am submitting.
 */
public class ArrayUtils {

  /* Part 1. Reducers */

  public static int reduceSum(int[] a) {
    return 0;
  }

  public static int reduceProduct(int[] a) {
    return 0;
  }

  public static int reduceCount(int[] a, int n) {
    return 0;
  }

  public static int reduceCountOdds(int[] a) {
    return 0;
  }

  public static int reduceMin(int[] a) {
    return 0;
  }

  public static int reduceMax(int[] a) {
    return 0;
  }

  /* Part 2. Logical Tests */

  public static boolean contains(int[] a, int n) {
    return false;
  }

  public static boolean every(int[] a, int n) {
    return false;
  }

  public static boolean equals(int[] a, int[] b) {
    return false;
  }

  /* Part 3. Stringify and Clone */

  public static String stringify(int[] a) {
    return "";
  }

  public static void print(int[] a) {
    System.out.println(ArrayUtils.stringify(a));
  }

  public static int[] clone(int[] a) {
    return null;
  }

  /* Part 4. Mappers */

  public static int[] mapSquare(int[] a) {
    return null;
  }

  public static int[] mapAdd(int[] a, int n) {
    return null;
  }

  public static int[] mapMultiply(int[] a, int n) {
    return null;
  }

  /* Part 5. Utilities */

  public static int[] reverse(int[] a) {
    return null;
  }

  public static int[] concatenate(int[] a, int[] b) {
    return null;
  }

  public static int[] subarray(int[] a, int start, int end) {
    return null;
  }

  public static int[] without(int[] a, int n) {
    return null;
  }

  public static int[] interleave(int[] a, int[] b) {
    return null;
  }

  public static int[] splice(int[] a, int offset, int[] b) {
    return null;
  }

}